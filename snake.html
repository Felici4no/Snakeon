<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake vs CPU - JS Puro</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --accent-color: #4CAF50;
            --cpu-color: #F44336;
            --fruit-color: #FFC107;
            --fruit-color: #FFC107;
            --rank-color: #9C27B0;
            --font-family: 'Press Start 2P', cursive, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Importar fonte pixelada */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: var(--accent-color);
            text-shadow: 4px 4px 0 #000;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 4px;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            /* Let clicks pass through to canvas if needed */
        }

        .score-box {
            display: flex;
            gap: 20px;
        }

        .p-score {
            color: var(--accent-color);
        }

        .cpu-score {
            color: var(--cpu-color);
        }

        .timer {
            color: #fff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        button {
            background: var(--accent-color);
            border: none;
            padding: 15px 30px;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: background 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #45a049;
        }

        #status-msg {
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .controls-hint {
            margin-top: 10px;
            font-size: 0.7rem;
            color: #888;
            line-height: 1.5;
        }

        /* Menu Styles */
        .menu-input {
            width: 300px;
            padding: 10px;
            margin: 10px auto;
            background: #222;
            color: #fff;
            border: 2px solid #555;
            font-family: var(--font-family);
            font-size: 0.9rem;
            text-align: center;
            text-transform: uppercase;
            box-sizing: border-box;
            display: block;
        }

        .menu-input:focus {
            border-color: var(--accent-color);
            outline: none;
        }

        .menu-btn {
            display: block;
            width: 300px;
            margin: 10px auto;
            background: #333;
            color: #fff;
            border: 2px solid #555;
            font-family: var(--font-family);
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .menu-btn:hover:not(:disabled) {
            background: var(--accent-color);
            border-color: #fff;
            transform: scale(1.05);
        }

        .menu-btn:disabled {
            background: #222;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .back-btn {
            background: transparent;
            border: 2px solid white;
            margin-top: 30px;
        }

        #credits-overlay {
            background: transparent;
            z-index: 20;
            pointer-events: none;
            /* Deixar cliques passarem para testar se preciso, mas o botão está dentro dele e precisa de clique. Melhor não user pointer-events none no container todo. */
        }

        #credits-overlay button {
            pointer-events: auto;
        }
    </style>
</head>

<body>

    <h1>Snake Battle</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="600"></canvas>

        <div id="ui-layer" style="display: none;">
            <div class="score-box">
                <span class="p-score">P1: <span id="pScoreVal">0</span></span>
                <span class="cpu-score">CPU: <span id="cpuScoreVal">0</span></span>
            </div>
            <div class="timer">TIME: <span id="timeVal">00:00</span></div>
        </div>

        <!-- MAIN MENU -->
        <div id="main-menu" class="overlay">
            <div id="status-msg" style="font-size: 1.5rem; color: var(--accent-color); margin-bottom: 40px;">BATTLE
                SNAKE</div>

            <input type="text" id="playerNameInput" class="menu-input" placeholder="SEU NOME" maxlength="10">

            <button class="menu-btn" onclick="startGame('pve')">P v BOT</button>
            <button class="menu-btn" disabled title="Em breve...">P v P (Trancado)</button>
            <button class="menu-btn" onclick="showRanking()">RANKING</button>
            <button class="menu-btn" onclick="showCredits()">CREDITS</button>
            <div class="controls-hint">Use <b>WASD</b> ou <b>Setas</b> para mover</div>
        </div>

        <!-- GAME OVER / PAUSE OVERLAY -->
        <div id="overlay" class="hidden">
            <div id="game-msg">GAME OVER</div>
            <div id="rank-msg" style="font-size: 0.8rem; color: #FFD700; margin-bottom: 20px; min-height: 20px;"></div>
            <button class="menu-btn" onclick="returnToMenu()">MENU PRINCIPAL</button>
            <button class="menu-btn" onclick="startGame('pve')">REVANCHE</button>
            <button class="menu-btn" onclick="showRanking()">VER RANKING</button>
        </div>

        <!-- RANKING OVERLAY -->
        <div id="ranking-overlay" class="hidden" onclick="returnToMenu()"
            style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index: 25; display:flex; flex-direction:column; align-items:center; justify-content:center; cursor: pointer;">
            <h2 style="color: var(--rank-color); margin-bottom: 30px; text-shadow: 2px 2px 0 #fff;">TOP 10</h2>
            <div id="ranking-list"
                style="font-family: 'Press Start 2P'; font-size: 0.8rem; line-height: 2; text-align: center; color: #fff;">
                <!-- Lista via JS -->
            </div>
            <div style="margin-top: 30px; font-size: 0.6rem; color: #777;">CLIQUE PARA VOLTAR</div>
        </div>

        <!-- CREDITS OVERLAY -->
        <div id="credits-overlay" class="hidden" onclick="returnToMenu()"
            style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; cursor: pointer;">
            <!-- Canvas will be used for pixel art text -->
        </div>
    </div>

    <script>
        /**
         * CONFIGURAÇÕES DO JOGO
         */
        const CANVAS_SIZE = 600;
        const TILE_SIZE = 20;
        const GRID_COUNT = CANVAS_SIZE / TILE_SIZE;
        const GAME_SPEED = 100; // ms por frame (menor = mais rápido)

        // Cores
        const COLOR_BG = '#000000';
        const COLOR_PLAYER = '#4CAF50';
        const COLOR_CPU = '#F44336';
        const COLOR_FRUIT = '#FFC107';

        /**
         * ESTADO DO JOGO
         */
        let canvas, ctx;
        let gameInterval;
        let timerInterval;
        let creditsInterval; // Animação dos créditos
        let startTime;
        let frameCounter = 0;
        let isGameOver = false;
        let gameState = 'MENU'; // MENU, PLAYING, CREDITS, RANKING

        // Entidades
        let player = {
            body: [],
            dir: { x: 1, y: 0 },
            nextDir: { x: 1, y: 0 }, // Buffer para evitar inputs conflitantes rápidos
            score: 0,
            color: COLOR_PLAYER,
            name: "Jogador",
            isDead: false
        };

        let cpu = {
            body: [],
            dir: { x: -1, y: 0 },
            score: 0,
            color: COLOR_CPU,
            name: "CPU",
            perceivedPlayerBody: [], // Visão atrasada do oponente
            isDead: false,
            deathTime: 0
        };

        let fruit = { x: 0, y: 0 };

        /**
         * INICIALIZAÇÃO
         */
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Listener de teclado
            document.addEventListener('keydown', handleInput);

            // Render menu inicial
            showMenu();
        };

        function showMenu() {
            gameState = 'MENU';
            document.getElementById('main-menu').style.display = 'flex'; // usar flex do css original #overlay ou setar
            // Ajustar display manualmente pois mudamos ids
            document.getElementById('main-menu').classList.remove('hidden');
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('main-menu').style.flexDirection = 'column';
            document.getElementById('main-menu').style.alignItems = 'center';
            document.getElementById('main-menu').style.justifyContent = 'center';
            document.getElementById('main-menu').style.position = 'absolute';
            document.getElementById('main-menu').style.top = '0';
            document.getElementById('main-menu').style.left = '0';
            document.getElementById('main-menu').style.width = '100%';
            document.getElementById('main-menu').style.height = '100%';
            document.getElementById('main-menu').style.background = 'rgba(0,0,0,0.9)';
            document.getElementById('main-menu').style.zIndex = '10';

            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('credits-overlay').classList.add('hidden');
            document.getElementById('ranking-overlay').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'none';

            clearInterval(gameInterval);
            clearInterval(timerInterval);
            clearInterval(creditsInterval); // Parar animação de créditos se houver

            // Desenhar fundo animado no menu?
            // Vamos apenas desenhar uma demo simples no fundo
            drawMenuBackground();
        }

        function startGame(mode) {
            gameState = 'PLAYING';
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('credits-overlay').classList.add('hidden');
            document.getElementById('ranking-overlay').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'flex';

            resetGameInternal();

            startTime = Date.now();

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(update, GAME_SPEED);

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
        }

        function returnToMenu() {
            showMenu();
        }

        function showCredits() {
            gameState = 'CREDITS';
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('credits-overlay').classList.remove('hidden');

            // Iniciar animação dos créditos
            if (creditsInterval) clearInterval(creditsInterval);

            let colorShift = 0;
            creditsInterval = setInterval(() => {
                colorShift += 10;
                drawPixelArtCredits(colorShift);
            }, 100);
        }

        // Função mágica para transformar texto em pixels no canvas
        function drawPixelArtCredits(hueShift) {
            // Limpar
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Usar um canvas temporário ou configurar fonte normal para ler pixels
            // Aqui vamos "simular" escrevendo na memória e transformando em blocos

            // Configurar texto
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Texto 1: LUCAS FELICIANO
            // Texto 2: GITHUB FELICI4NO

            // A ideia é: desenhar texto pequeno, pegar pixels, desenhar grande
            // Posição virtual
            const offC = document.createElement('canvas');
            offC.width = 100; // baixa resolução
            offC.height = 100;
            const offCtx = offC.getContext('2d');

            offCtx.fillStyle = '#fff'; // Texto branco
            // Fonte não precisa ser pixelada aqui, pois vamos pixelizar nós mesmos
            offCtx.font = 'bold 10px sans-serif';
            offCtx.textAlign = 'center';

            // Desenhar linha 1
            offCtx.fillText('LUCAS', 50, 20);
            offCtx.fillText('FELICIANO', 50, 35);

            // Desenhar linha 2
            offCtx.fillText('GITHUB', 50, 60);
            offCtx.fillText('FELICI4NO', 50, 75);

            // Ler dados
            const imgData = offCtx.getImageData(0, 0, 100, 100);
            const data = imgData.data;

            // Renderizar no canvas principal como blocos
            // O canvas principal tem GRID_COUNT blocos (30x30).
            // O offscreen tem 100x100. Vamos mapear, escalando.

            // Melhor abordagem manual para layout bonito:
            // 40x40 grid fictício para render
            const scale = 6;
            const offsetX = 0;
            const offsetY = 0;

            for (let y = 0; y < 100; y++) {
                for (let x = 0; x < 100; x++) {
                    const alpha = data[(y * 100 + x) * 4 + 3];
                    if (alpha > 128) {
                        // Pixel ativo -> desenha bloco
                        const hue = (x * 5 + y * 5 + hueShift) % 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        ctx.fillRect(x * scale, y * scale, scale - 1, scale - 1);
                    }
                }
            }
        }

        function drawMenuBackground() {
            // Desenha algo estático ou em loop no menu só pra não ficar preto
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Grid
            ctx.strokeStyle = '#111';
            for (let i = 0; i < GRID_COUNT; i++) {
                ctx.beginPath(); ctx.moveTo(i * TILE_SIZE, 0); ctx.lineTo(i * TILE_SIZE, CANVAS_SIZE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * TILE_SIZE); ctx.lineTo(CANVAS_SIZE, i * TILE_SIZE); ctx.stroke();
            }
        }

        function resetGameInternal() {
            isGameOver = false;
            frameCounter = 0;

            // Resetar Jogador (começa na esquerda)
            player.body = [
                { x: 5, y: 10 },
                { x: 4, y: 10 },
                { x: 3, y: 10 }
            ];
            player.dir = { x: 1, y: 0 };
            player.nextDir = { x: 1, y: 0 };
            player.score = 0;
            player.isDead = false;

            // Resetar CPU (começa na direita)
            cpu.body = [
                { x: GRID_COUNT - 6, y: 10 },
                { x: GRID_COUNT - 5, y: 10 },
                { x: GRID_COUNT - 4, y: 10 }
            ];
            cpu.dir = { x: -1, y: 0 };
            cpu.score = 0;
            cpu.isDead = false;
            // Inicializar a percepção da CPU
            cpu.perceivedPlayerBody = [];

            // Spawnar fruta inicial
            spawnFruit();

            // Atualizar UI
            updateUI();
            document.getElementById('timeVal').innerText = "00:00";
        }

        /**
            // Se a cpu perder os pontos pro player, ela não tem score pra salvar.
        }

        /**
         * RANKING SYSTEM
         */
        function getHighScores() {
            const scores = localStorage.getItem('snake_high_scores');
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighScore(score) {
            const scores = getHighScores();
            const date = new Date().toLocaleDateString('pt-BR');
            // Simplesmente "Jogador" como nome ou pedir input?
            // Para simplificar e manter fluxo rápido, usaremos "Jogador"
            // Se quiser input, teria que mudar UI.
            const newEntry = { name: "PLAYER", score: score, date: date };

            scores.push(newEntry);
            scores.sort((a, b) => b.score - a.score);
            scores.splice(10); // Manter top 10

            localStorage.setItem('snake_high_scores', JSON.stringify(scores));

            // Retorna a posição (1-based) ou -1 se não entrou
            return scores.indexOf(newEntry) + 1;
        }

        function checkRank(score) {
            const scores = getHighScores();
            if (scores.length < 10) return true;
            return score > scores[scores.length - 1].score;
        }

        function showRanking() {
            gameState = 'RANKING';
            // Montar lista HTML
            const scores = getHighScores();
            const listEl = document.getElementById('ranking-list');

            if (scores.length === 0) {
                listEl.innerHTML = "SEM REGRISTROS AINDA";
            } else {
                listEl.innerHTML = scores.map((s, i) =>
                    `<div>#${i + 1} ${s.name} ... ${s.score}</div>`
                ).join('');
            }

            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('ranking-overlay').classList.remove('hidden');
        }

        function handleInput(e) {
            if (gameState === 'CREDITS' || gameState === 'RANKING') {
                returnToMenu();
                return;
            }

            if (isGameOver) return;

            const key = e.key;

            // Impedir rolagem da página com setas
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(key) > -1) {
                e.preventDefault();
            }

            const goingUp = player.dir.y === -1;
            const goingDown = player.dir.y === 1;
            const goingRight = player.dir.x === 1;
            const goingLeft = player.dir.x === -1;

            // Definir nextDir em vez de dir diretamente para evitar suicídio em inputs rápidos
            if ((key === 'ArrowUp' || key === 'w' || key === 'W') && !goingDown) {
                player.nextDir = { x: 0, y: -1 };
            }
            if ((key === 'ArrowDown' || key === 's' || key === 'S') && !goingUp) {
                player.nextDir = { x: 0, y: 1 };
            }
            if ((key === 'ArrowLeft' || key === 'a' || key === 'A') && !goingRight) {
                player.nextDir = { x: -1, y: 0 };
            }
            if ((key === 'ArrowRight' || key === 'd' || key === 'D') && !goingLeft) {
                player.nextDir = { x: 1, y: 0 };
            }
        }

        /**
         * LÓGICA DA I.A. (CPU)
         */
        function updateCPULogic() {
            if (cpu.isDead) return;

            const head = cpu.body[0];

            // Movimentos possíveis
            const moves = [
                { x: 0, y: -1 }, // U
                { x: 0, y: 1 },  // D
                { x: -1, y: 0 }, // L
                { x: 1, y: 0 }   // R
            ];

            // Atualizar percepção do oponente com "lag" (reflexo humano)
            // A CPU só atualiza onde o player está a cada 3 frames (300ms)
            // Se o player se mover bruscamente nos intervalos, a CPU não "vê" e bate.
            if (frameCounter % 3 === 0) {
                // Deep copy simples para não manter referência
                cpu.perceivedPlayerBody = player.body.map(p => ({ ...p }));
            }
            // Se perceivedPlayerBody estiver vazio (inicio), preenche
            if (cpu.perceivedPlayerBody.length === 0 && player.body.length > 0) {
                cpu.perceivedPlayerBody = player.body.map(p => ({ ...p }));
            }

            // 1. Filtrar movimentos suicidas (paredes ou colisão imediata)
            // Nota: Evitar "pescoço" (voltar para trás) já está coberto pela verificação de colisão com corpo,
            // mas podemos ser explícitos.
            let safeMoves = moves.filter(move => {
                const nextX = head.x + move.x;
                const nextY = head.y + move.y;

                // Não pode voltar imediatamente para trás
                if (move.x === -cpu.dir.x && move.y === -cpu.dir.y) return false;

                return isSafeForCPU(nextX, nextY);
            });

            // Se não houver movimentos seguros, manter a direção (e morrer) ou tentar qualquer um
            if (safeMoves.length === 0) return;

            // 2. Escolher o movimento que minimiza a distância até a fruta
            // Ordenar movimentos por distância até a fruta
            safeMoves.sort((a, b) => {
                const distA = getDistance(head.x + a.x, head.y + a.y, fruit.x, fruit.y);
                const distB = getDistance(head.x + b.x, head.y + b.y, fruit.x, fruit.y);
                return distA - distB;
            });

            // Escolher o melhor
            cpu.dir = safeMoves[0];
        }

        // Função de segurança usada pela IA - usa a percepção "atrasada" do player
        function isSafeForCPU(x, y) {
            // Paredes (Realidade - CPU vê paredes perfeitamente)
            if (x < 0 || x >= GRID_COUNT || y < 0 || y >= GRID_COUNT) return false;

            // Colisão com PLAYER (Percepção Atrasada)
            for (let part of cpu.perceivedPlayerBody) {
                if (x === part.x && y === part.y) return false;
            }

            // Colisão com PRÓPRIO CORPO (Realidade - Propriocepção perfeita)
            for (let i = 0; i < cpu.body.length - 1; i++) {
                if (x === cpu.body[i].x && y === cpu.body[i].y) return false;
            }

            return true;
        }

        // Função Genérica (não usada mais pela IA diretamente, mas útil se precisarmos da verdade)
        function isSafe(x, y) { return true; } // Placeholder ou deprecated para lógica da IA

        function getDistance(x1, y1, x2, y2) {
            // Distância Manhattan (funciona bem para grids) ou Euclidiana
            // Manhattan: |x1 - x2| + |y1 - y2|
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        /**
         * ENGINE PRINCIPAL
         */
        function update() {
            if (isGameOver) return;
            frameCounter++;

            // Verificar scores para vitória
            if (player.score >= 500) {
                gameOver("VOCÊ ATINGIU 500 PONTOS! VENCEU!");
                return;
            }
            if (cpu.score >= 500) {
                gameOver("CPU ATINGIU 500 PONTOS! PERDEU!");
                return;
            }

            // Atualizar direção do player baseada no buffer
            player.dir = player.nextDir;

            // Calcular IA
            updateCPULogic();

            // Lógica de Morte da CPU (Respawn Delay)
            if (cpu.isDead) {
                if (Date.now() - cpu.deathTime > 2000) { // 2 segundos
                    respawnCpu();
                }
                // Não move a CPU se estiver morta
            } else {
                moveSnake(cpu);
            }

            // Mover Jogador
            moveSnake(player);

            // Verificar colisões após movimento
            // Se CPU morreu neste frame (dentro de move -> não, move é move), collisions checa resultados.
            // Precisamos checar colisão da CPU apenas se ela estiver viva
            let cpuCollision = false;

            if (!cpu.isDead) {
                if (checkCollisions(cpu)) cpuCollision = true;
            }

            if (checkCollisions(player) || cpuCollision) {
                return;
            }

            // Verificar se comeram a fruta
            checkFruit(player);
            if (!cpu.isDead) checkFruit(cpu);

            draw();
        }

        function moveSnake(snake) {
            // Nova cabeça
            const head = {
                x: snake.body[0].x + snake.dir.x,
                y: snake.body[0].y + snake.dir.y
            };

            // Adiciona nova cabeça
            snake.body.unshift(head);

            // Remove a cauda (será recolocada se comer fruta, mas fazemos isso na checkFruit logicamente:
            // aqui removemos sempre, e na checkFruit a gente só não removeu a cauda no frame anterior? 
            // Abordagem comum: move remove tail. Se comer, cresce (add tail back or don't remove).
            // Vamos usar: sempre remove, se comer, adiciona de volta (ou simplesmente não remove lá).
            // Para simplificar renderização suave: removemos aqui.)
            snake.body.pop();
        }

        function checkCollisions(snake) {
            const head = snake.body[0];

            // 1. Paredes
            if (head.x < 0 || head.x >= GRID_COUNT || head.y < 0 || head.y >= GRID_COUNT) {
                if (snake === cpu) {
                    // Se CPU bate na parede, ela morre/respawna?
                    // Mantendo regra original: colisão com parede = perde.
                    gameOver(`${snake.name} bateu na parede!`);
                    return true;
                }
                gameOver(`${snake.name} bateu na parede!`);
                return true;
            }

            // 2. Colisão com o outro player
            const otherSnake = (snake === player) ? cpu : player;
            for (let part of otherSnake.body) {
                // Verificar se a cabeça de 'snake' bate em 'part'
                if (head.x === part.x && head.y === part.y) {
                    // NOVA REGRA: Se CPU bater no Jogador
                    if (snake === cpu && otherSnake === player) {
                        triggerCpuDeath();
                        return false; // Jogo continua
                    }

                    // Se Jogador bater na CPU (ou CPU bater em CPU)
                    // Se a CPU estiver MORTA (piscando), considerar "ghost" (sem colisão)?
                    // O usuario pediu "aparecer de novo", então durante o piscar ela é um fantasma.
                    if (otherSnake === cpu && cpu.isDead) {
                        return false; // Ignora colisão com corpo morto
                    }

                    gameOver(`${snake.name} colidiu com o inimigo!`);
                    return true;
                }
            }

            // 3. Auto-colisão
            for (let i = 1; i < snake.body.length; i++) {
                if (head.x === snake.body[i].x && head.y === snake.body[i].y) {
                    // Se CPU se enrolar, ela morre e respawna sem dar pontos?
                    // Vamos considerar Game Over para consistência competitiva, ou respawn?
                    // "Uma cobra controlada pelo computador... morre... e aparece uma nova"
                    // Vamos aplicar respawn para CPU se enrolar também para não acabar o jogo cedo.
                    if (snake === cpu) {
                        triggerCpuDeath();
                        return false;
                    }

                    gameOver(`${snake.name} se enrolou!`);
                    return true;
                }
            }

            return false;
        }

        function checkFruit(snake) {
            const head = snake.body[0];
            if (head.x === fruit.x && head.y === fruit.y) {
                // Crescer
                const tail = snake.body[snake.body.length - 1];
                snake.body.push({ ...tail });

                snake.score += 10;
                updateUI();
                spawnFruit();
            }
        }

        function triggerCpuDeath() {
            if (cpu.isDead) return;

            // Transferir pontos
            player.score += cpu.score;
            cpu.score = 0;
            updateUI();

            // Setar estado de morte
            cpu.isDead = true;
            cpu.deathTime = Date.now();
        }

        function respawnCpu() {
            cpu.isDead = false;
            // Tentar encontrar uma posição segura aleatória
            let valid = false;
            let newBody = [];
            let attempts = 0;

            while (!valid && attempts < 100) {
                attempts++;
                // Posição aleatória para a cabeça
                const hx = Math.floor(Math.random() * (GRID_COUNT - 10)) + 5;
                const hy = Math.floor(Math.random() * (GRID_COUNT - 10)) + 5;

                // Corpo inicial (3 segmentos)
                newBody = [
                    { x: hx, y: hy },
                    { x: hx + 1, y: hy }, // Cauda para direita (já que dir será esquerda)
                    { x: hx + 2, y: hy }
                ];

                // Verificar colisão com paredes ou player
                valid = true;
                for (let part of newBody) {
                    // Paredes (implícito pelo random range, mas ok)
                    // Player
                    for (let pPart of player.body) {
                        if (part.x === pPart.x && part.y === pPart.y) valid = false;
                    }
                    // Fruta
                    if (part.x === fruit.x && part.y === fruit.y) valid = false;
                }
            }

            // Fallback se n achar
            if (!valid) {
                newBody = [
                    { x: GRID_COUNT - 6, y: 10 },
                    { x: GRID_COUNT - 5, y: 10 },
                    { x: GRID_COUNT - 4, y: 10 }
                ];
            }

            cpu.body = newBody;
            cpu.perceivedPlayerBody = []; // Resetar percepção ao renascer
            cpu.dir = { x: -1, y: 0 };
            // Score já foi resetado antes
        }

        function spawnFruit() {
            let valid = false;
            while (!valid) {
                fruit.x = Math.floor(Math.random() * GRID_COUNT);
                fruit.y = Math.floor(Math.random() * GRID_COUNT);

                valid = true;
                // Não spawnar em cima de cobras
                [player, cpu].forEach(s => {
                    for (let part of s.body) {
                        if (part.x === fruit.x && part.y === fruit.y) valid = false;
                    }
                });
            }
        }

        function gameOver(reason) {
            isGameOver = true;
            clearInterval(gameInterval);
            clearInterval(timerInterval);

            // Determinar vencedor e perdedor
            let winner = "";
            let color = "#fff";
            let playerLost = false;

            if (reason.includes("Empate")) {
                winner = "EMPATE!";
            } else if (reason.includes(player.name) || reason.includes("CPU ATINGIU")) {
                winner = "CPU VENCEU!";
                color = COLOR_CPU;
                playerLost = true;
                player.isDead = true; // Ativar efeito visual
            } else {
                winner = "VOCÊ VENCEU!";
                color = COLOR_PLAYER;
            }

            const titleHtml = `<span style="color:${color}; font-size: 1.5rem; text-shadow: 2px 2px #000;">${winner}</span>`;
            const reasonHtml = `<br><br><span style="font-size:0.8rem; color:#ccc">${reason}</span>`;

            const msg = document.getElementById('game-msg'); // Corrected to target 'game-msg'
            msg.innerHTML = titleHtml + reasonHtml;

            // Lógica de Ranking
            const rankMsg = document.getElementById('rank-msg');
            let rankText = "";
            let rank = -1;

            // Salvar apenas se o jogador jogou (não se a CPU ganhou sozinha sem player pontuar?)
            // Regra: Qualquer jogo conta. Se player fez pontos, tenta ranking.
            if (player.score > 0) {
                rank = saveHighScore(player.score);
            }

            if (rank > 0) {
                rankText = `NOVO RECORDE! POSIÇÃO #${rank}`;
                // Auto-mostrar ranking após overlay de game over?
                // O usuario pediu: "o ranking deve aparecer e o usuario ser informado"
                // Vamos mostrar msg aqui, e dar opção de ver.
            } else {
                rankText = "Tente bater o recorde!";
            }
            rankMsg.innerText = rankText;


            const overlay = document.getElementById('overlay');
            // Se o jogador perdeu, dar delay para mostrar onde morreu
            if (playerLost) {
                // Animação de morte (Game Loop parou, então precisamos forçar frames de desenho)
                let deathFrames = 0;
                const deathInterval = setInterval(() => {
                    draw();
                    deathFrames++;
                    if (deathFrames > 20) { // ~2 segundos (100ms * 20)
                        clearInterval(deathInterval);
                        overlay.classList.remove('hidden');
                        if (rank > 0) {
                            // Se bateu recorde, talvez piscar ou algo especial?
                        }
                    }
                }, 100);
            } else {
                overlay.classList.remove('hidden');
            }
        }

        function updateTimer() {
            const now = Date.now();
            const diff = Math.floor((now - startTime) / 1000);

            const m = Math.floor(diff / 60).toString().padStart(2, '0');
            const s = (diff % 60).toString().padStart(2, '0');

            document.getElementById('timeVal').innerText = `${m}:${s}`;
        }

        function updateUI() {
            document.getElementById('pScoreVal').innerText = player.score;
            document.getElementById('cpuScoreVal').innerText = cpu.score;
        }

        /**
         * RENDERIZAÇÃO
         */
        function draw() {
            // Limpar fundo
            ctx.fillStyle = COLOR_BG;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Desenhar Grid (opcional, leve)
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            /*
            for (let i = 0; i < gridCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * tileSize, 0);
                ctx.lineTo(i * tileSize, canvasSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * tileSize);
                ctx.lineTo(canvasSize, i * tileSize);
                ctx.stroke();
            }
            */

            // Desenhar Fruta
            drawRect(fruit.x, fruit.y, COLOR_FRUIT);

            // Desenhar Player
            drawSnake(player);

            // Desenhar CPU
            drawSnake(cpu);
        }

        function drawSnake(snake) {
            // Efeito de piscar se estiver morto
            if (snake.isDead) {
                // Piscar a cada 200ms
                if (Math.floor(Date.now() / 200) % 2 === 0) {
                    return; // Não desenha neste frame (fundo preto)
                }
            }

            ctx.fillStyle = snake.color;
            snake.body.forEach((part, index) => {
                // Cabeça um pouco mais clara ou diferente
                if (index === 0) {
                    ctx.fillStyle = '#fff'; // Olho/Brilho na cabeça
                    drawRect(part.x, part.y, snake.color); // Base

                    // Desenhar um "olho" simples
                    ctx.fillStyle = 'white';
                    const px = part.x * TILE_SIZE;
                    const py = part.y * TILE_SIZE;
                    // Centro
                    ctx.fillRect(px + 4, py + 4, 12, 12);
                    // Volta a cor base
                    ctx.fillStyle = snake.color;
                    // Pupila baseada na cor da cobra
                    ctx.fillRect(px + 8, py + 8, 4, 4);
                } else {
                    ctx.fillStyle = snake.color;
                    drawRect(part.x, part.y, snake.color);
                }
            });
        }

        function drawRect(x, y, color) {
            ctx.fillStyle = color;
            // -1 no tamanho para dar efeito de grid separado
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 2, TILE_SIZE - 2);
        }

    </script>
</body>

</html>