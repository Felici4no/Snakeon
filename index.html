<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake vs CPU - JS Puro</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --accent-color: #4CAF50;
            --cpu-color: #F44336;
            --fruit-color: #FFC107;
            --fruit-color: #FFC107;
            --rank-color: #9C27B0;
            --font-family: 'Press Start 2P', cursive, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Importar fonte pixelada */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: var(--accent-color);
            text-shadow: 4px 4px 0 #000;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 4px;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            /* Let clicks pass through to canvas if needed */
        }

        .score-box {
            display: flex;
            gap: 20px;
        }

        .p-score {
            color: var(--accent-color);
        }

        .cpu-score {
            color: var(--cpu-color);
        }

        .timer {
            color: #fff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        button {
            background: var(--accent-color);
            border: none;
            padding: 15px 30px;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: background 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #45a049;
        }

        #status-msg {
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .controls-hint {
            margin-top: 10px;
            font-size: 0.7rem;
            color: #888;
            line-height: 1.5;
        }

        /* Menu Styles */
        .menu-input {
            width: 300px;
            padding: 10px;
            margin: 10px auto;
            background: #222;
            color: #fff;
            border: 2px solid #555;
            font-family: var(--font-family);
            font-size: 0.9rem;
            text-align: center;
            text-transform: uppercase;
            box-sizing: border-box;
            display: block;
        }

        .menu-input:focus {
            border-color: var(--accent-color);
            outline: none;
        }

        .menu-btn {
            display: block;
            width: 300px;
            margin: 10px auto;
            background: #333;
            color: #fff;
            border: 2px solid #555;
            font-family: var(--font-family);
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .menu-btn:hover:not(:disabled) {
            background: var(--accent-color);
            border-color: #fff;
            transform: scale(1.05);
        }

        .menu-btn:disabled {
            background: #222;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .back-btn {
            background: transparent;
            border: 2px solid white;
            margin-top: 30px;
        }

        #credits-overlay {
            background: transparent;
            z-index: 20;
            pointer-events: none;
            /* Deixar cliques passarem para testar se preciso, mas o botão está dentro dele e precisa de clique. Melhor não user pointer-events none no container todo. */
        }

        #credits-overlay button {
            pointer-events: auto;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            /* Default hidden on desktop */
            margin-top: 20px;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .d-pad-row {
            display: flex;
            gap: 10px;
        }

        .d-btn {
            width: 60px;
            height: 60px;
            background: #333;
            border: 2px solid #555;
            border-radius: 10px;
            color: #fff;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .d-btn:active {
            background: var(--accent-color);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            body {
                justify-content: flex-start;
                padding-top: 20px;
                height: 100%;
                overflow: auto;
            }

            #game-container {
                width: 90vw;
                height: 90vw;
                /* Keep aspect ratio square */
                max-width: 400px;
                max-height: 400px;
            }

            canvas {
                width: 100% !important;
                height: 100% !important;
            }

            #mobile-controls {
                display: flex;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 10px;
            }
        }
    </style>
</head>

<body>

    <h1>Snake Battle</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="600"></canvas>

        <div id="ui-layer" style="display: none;">
            <div class="score-box">
                <span class="p-score">P1: <span id="pScoreVal">0</span></span>
                <span class="cpu-score">CPU: <span id="cpuScoreVal">0</span></span>
            </div>
            <div class="timer">TIME: <span id="timeVal">00:00</span></div>
        </div>

        <!-- MAIN MENU -->
        <div id="main-menu" class="overlay">
            <div id="status-msg" style="font-size: 1.5rem; color: var(--accent-color); margin-bottom: 40px;">BATTLE
                SNAKE</div>

            <input type="text" id="playerNameInput" class="menu-input" placeholder="SEU NOME" maxlength="10">

            <button class="menu-btn" onclick="startGame('pve')">START BATTLE</button>

            <button class="menu-btn" onclick="showRanking()">RANKING</button>
            <button class="menu-btn" onclick="showCredits()">CREDITS</button>
            <div class="controls-hint">Use <b>WASD</b> ou <b>Setas</b> para mover</div>
        </div>

        <!-- GAME OVER / PAUSE OVERLAY -->
        <div id="overlay" class="hidden">
            <div id="game-msg">GAME OVER</div>
            <div id="rank-msg" style="font-size: 0.8rem; color: #FFD700; margin-bottom: 20px; min-height: 20px;"></div>
            <button class="menu-btn" onclick="returnToMenu()">MENU PRINCIPAL</button>
            <button class="menu-btn" onclick="startGame('pve')">REVANCHE</button>
            <button class="menu-btn" onclick="showRanking()">VER RANKING</button>
        </div>

        <!-- RANKING OVERLAY -->
        <div id="ranking-overlay" class="hidden" onclick="returnToMenu()"
            style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index: 25; display:flex; flex-direction:column; align-items:center; justify-content:center; cursor: pointer;">
            <h2 style="color: var(--rank-color); margin-bottom: 30px; text-shadow: 2px 2px 0 #fff;">TOP 10</h2>
            <div id="ranking-list"
                style="font-family: 'Press Start 2P'; font-size: 0.8rem; line-height: 2; text-align: center; color: #fff;">
                <!-- Lista via JS -->
            </div>
            <div style="margin-top: 30px; font-size: 0.6rem; color: #777;">CLIQUE PARA VOLTAR</div>
        </div>

        <!-- CREDITS OVERLAY -->
        <div id="credits-overlay" class="hidden" onclick="returnToMenu()"
            style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; cursor: pointer;">
            <!-- Canvas will be used for pixel art text -->
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div class="d-pad-row">
            <div class="d-btn" ontouchstart="handleMobileInput('ArrowUp')" onclick="handleMobileInput('ArrowUp')">▲
            </div>
        </div>
        <div class="d-pad-row">
            <div class="d-btn" ontouchstart="handleMobileInput('ArrowLeft')" onclick="handleMobileInput('ArrowLeft')">◄
            </div>
            <div class="d-btn" style="visibility: hidden;"></div> <!-- Spacer -->
            <div class="d-btn" ontouchstart="handleMobileInput('ArrowRight')" onclick="handleMobileInput('ArrowRight')">
                ►</div>
        </div>
        <div class="d-pad-row">
            <div class="d-btn" ontouchstart="handleMobileInput('ArrowDown')" onclick="handleMobileInput('ArrowDown')">▼
            </div>
        </div>
    </div>

    <script>
        /**
         * CONFIGURAÇÕES DO JOGO
         */
        const CANVAS_SIZE = 600;
        const TILE_SIZE = 20;
        const GRID_COUNT = CANVAS_SIZE / TILE_SIZE;
        const GAME_SPEED = 100; // ms por frame (menor = mais rápido)

        // Cores
        const COLOR_BG = '#000000';
        const COLOR_PLAYER = '#4CAF50';
        const COLOR_CPU = '#F44336';
        const COLOR_FRUIT = '#FFC107';

        /**
         * ESTADO DO JOGO
         */
        let canvas, ctx;
        let gameInterval;
        let timerInterval;
        let creditsInterval;
        let gameStartTime = 0; // Correctly initialized
        let frameCounter = 0;
        let isGameOver = false;
        let gameState = 'MENU'; // MENU, PLAYING, CREDITS, RANKING

        // Entidades
        let player = {
            body: [],
            dir: { x: 1, y: 0 },
            nextDir: { x: 1, y: 0 }, // Buffer para evitar inputs conflitantes rápidos
            score: 0,
            color: COLOR_PLAYER,
            name: "Jogador",
            isDead: false
        };

        let cpu = {
            body: [],
            dir: { x: -1, y: 0 },
            score: 0,
            color: COLOR_CPU,
            name: "CPU",
            perceivedPlayerBody: [], // Visão atrasada do oponente
            isDead: false,
            deathTime: 0
        };

        let fruit = { x: 0, y: 0 };

        /**
         * INICIALIZAÇÃO
         */
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Listener de teclado
            document.addEventListener('keydown', handleInput);

            // Render menu inicial
            showMenu();
        };

        function showMenu() {
            gameState = 'MENU';
            document.getElementById('main-menu').style.display = 'flex'; // usar flex do css original #overlay ou setar
            // Ajustar display manualmente pois mudamos ids
            document.getElementById('main-menu').classList.remove('hidden');
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('main-menu').style.flexDirection = 'column';
            document.getElementById('main-menu').style.alignItems = 'center';
            document.getElementById('main-menu').style.justifyContent = 'center';
            document.getElementById('main-menu').style.position = 'absolute';
            document.getElementById('main-menu').style.top = '0';
            document.getElementById('main-menu').style.left = '0';
            document.getElementById('main-menu').style.width = '100%';
            document.getElementById('main-menu').style.height = '100%';
            document.getElementById('main-menu').style.background = 'rgba(0,0,0,0.9)';
            document.getElementById('main-menu').style.zIndex = '10';

            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('credits-overlay').classList.add('hidden');
            document.getElementById('ranking-overlay').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'none';

            clearInterval(gameInterval);
            clearInterval(timerInterval);
            clearInterval(creditsInterval); // Parar animação de créditos se houver

            // Desenhar fundo animado no menu?
            // Vamos apenas desenhar uma demo simples no fundo
            drawMenuBackground();
        }

        function startGame(mode) {
            gameState = 'PLAYING';

            // Capturar nome
            const nameInput = document.getElementById('playerNameInput').value.trim();
            if (nameInput) {
                player.name = nameInput.toUpperCase();
            } else {
                player.name = "JOGADOR";
            }

            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('credits-overlay').classList.add('hidden');
            document.getElementById('ranking-overlay').classList.add('hidden');
            document.getElementById('ui-layer').style.display = 'flex';

            resetGameInternal();
            startTimer();
        }

        function startTimer() {
            if (gameInterval) clearInterval(gameInterval);
            if (timerInterval) clearInterval(timerInterval);

            gameStartTime = performance.now();
            gameInterval = setInterval(update, GAME_SPEED);
            timerInterval = setInterval(updateTimer, 1000);

            isGameOver = false;
        }

        function stopTimer() {
            clearInterval(gameInterval);
            clearInterval(timerInterval);
        }

        function returnToMenu() {
            showMenu();
        }

        function showCredits() {
            gameState = 'CREDITS';
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('credits-overlay').classList.remove('hidden');

            // Iniciar animação dos créditos
            if (creditsInterval) clearInterval(creditsInterval);

            let colorShift = 0;
            creditsInterval = setInterval(() => {
                colorShift += 10;
                drawPixelArtCredits(colorShift);
            }, 100);
        }

        // Função mágica para transformar texto em pixels no canvas
        function drawPixelArtCredits(hueShift) {
            // Limpar
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Usar um canvas temporário ou configurar fonte normal para ler pixels
            // Aqui vamos "simular" escrevendo na memória e transformando em blocos

            // Configurar texto
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Texto 1: LUCAS FELICIANO
            // Texto 2: GITHUB FELICI4NO

            // A ideia é: desenhar texto pequeno, pegar pixels, desenhar grande
            // Posição virtual
            const offC = document.createElement('canvas');
            offC.width = 100; // baixa resolução
            offC.height = 100;
            const offCtx = offC.getContext('2d');

            offCtx.fillStyle = '#fff'; // Texto branco
            // Fonte não precisa ser pixelada aqui, pois vamos pixelizar nós mesmos
            offCtx.font = 'bold 10px sans-serif';
            offCtx.textAlign = 'center';

            // Desenhar linha 1
            offCtx.fillText('LUCAS', 50, 20);
            offCtx.fillText('FELICIANO', 50, 35);

            // Desenhar linha 2
            offCtx.fillText('GITHUB', 50, 60);
            offCtx.fillText('FELICI4NO', 50, 75);

            // Ler dados
            const imgData = offCtx.getImageData(0, 0, 100, 100);
            const data = imgData.data;

            // Renderizar no canvas principal como blocos
            // O canvas principal tem GRID_COUNT blocos (30x30).
            // O offscreen tem 100x100. Vamos mapear, escalando.

            // Melhor abordagem manual para layout bonito:
            // 40x40 grid fictício para render
            const scale = 6;
            const offsetX = 0;
            const offsetY = 0;

            for (let y = 0; y < 100; y++) {
                for (let x = 0; x < 100; x++) {
                    const alpha = data[(y * 100 + x) * 4 + 3];
                    if (alpha > 128) {
                        // Pixel ativo -> desenha bloco
                        const hue = (x * 5 + y * 5 + hueShift) % 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        ctx.fillRect(x * scale, y * scale, scale - 1, scale - 1);
                    }
                }
            }
        }

        function drawMenuBackground() {
            // Desenha algo estático ou em loop no menu só pra não ficar preto
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Grid
            ctx.strokeStyle = '#111';
            for (let i = 0; i < GRID_COUNT; i++) {
                ctx.beginPath(); ctx.moveTo(i * TILE_SIZE, 0); ctx.lineTo(i * TILE_SIZE, CANVAS_SIZE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * TILE_SIZE); ctx.lineTo(CANVAS_SIZE, i * TILE_SIZE); ctx.stroke();
            }
        }

        function resetGameInternal() {
            isGameOver = false;
            frameCounter = 0;

            // Resetar Jogador (começa na esquerda)
            player.body = [
                { x: 5, y: 10 },
                { x: 4, y: 10 },
                { x: 3, y: 10 }
            ];
            player.dir = { x: 1, y: 0 };
            player.nextDir = { x: 1, y: 0 };
            player.score = 0;
            player.isDead = false;

            // Resetar CPU (começa na direita)
            cpu.body = [
                { x: GRID_COUNT - 6, y: 10 },
                { x: GRID_COUNT - 5, y: 10 },
                { x: GRID_COUNT - 4, y: 10 }
            ];
            cpu.dir = { x: -1, y: 0 };
            cpu.score = 0;
            cpu.isDead = false;
            // Inicializar a percepção da CPU
            cpu.perceivedPlayerBody = [];

            // Spawnar fruta inicial
            spawnFruit();

            // Atualizar UI
            updateUI();
            document.getElementById('timeVal').innerText = "00:00";
        }


        /**
         * API BACKEND INTEGRATION
         */
        const API_URL = "https://yellow-pine-e4b5snake-verifier.lucas-for-study-42.workers.dev";

        async function submitScoreSafe(name, score, timeMs) {
            // Garantir inteiros
            const finalTime = Math.floor(timeMs);
            const finalScore = Math.floor(score);

            console.log(`Submitting: ${name}, Score: ${finalScore}, Time: ${finalTime}ms`);
            try {
                const res = await fetch(`${API_URL}/submit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        score: finalScore,
                        time_ms: finalTime
                    })
                });
                if (!res.ok) throw new Error("API responded with error");
                console.log("Score submitted successfully");
                return true;
            } catch (e) {
                console.error("Error submitting score:", e);
                return false;
            }
        }

        async function fetchRanking() {
            try {
                const res = await fetch(`${API_URL}/ranking`);
                if (!res.ok) throw new Error("API Error");
                const data = await res.json();
                return data;
            } catch (e) {
                console.error("Error fetching ranking:", e);
                return [];
            }
        }

        async function showRanking() {
            gameState = 'RANKING';
            const listEl = document.getElementById('ranking-list');
            listEl.innerHTML = "CARREGANDO...";

            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('ranking-overlay').classList.remove('hidden');

            const scores = await fetchRanking();

            if (!scores || scores.length === 0) {
                listEl.innerHTML = "SEM REGISTROS OU OFFLINE";
            } else {
                // Backend retorna [{name, score, time_ms}, ...]. 
                listEl.innerHTML = scores.map((s, i) => {
                    const totalSeconds = Math.floor(s.time_ms / 1000);
                    const tm = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                    const ts = (totalSeconds % 60).toString().padStart(2, '0');
                    // Exibir: #1 NOME - 100pts - 01:23
                    return `<div>#${i + 1} ${s.name} - ${s.score}pts - ${tm}:${ts}</div>`;
                }).join('');
            }
        }

        function handleInput(e) {
            if (gameState === 'CREDITS' || gameState === 'RANKING') {
                returnToMenu();
                return;
            }

            if (isGameOver) return;

            const key = e.key;

            // Impedir rolagem da página com setas
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(key) > -1) {
                e.preventDefault();
            }

            const goingUp = player.dir.y === -1;
            const goingDown = player.dir.y === 1;
            const goingRight = player.dir.x === 1;
            const goingLeft = player.dir.x === -1;

            // Definir nextDir em vez de dir diretamente para evitar suicídio em inputs rápidos
            if ((key === 'ArrowUp' || key === 'w' || key === 'W') && !goingDown) {
                player.nextDir = { x: 0, y: -1 };
            }
            if ((key === 'ArrowDown' || key === 's' || key === 'S') && !goingUp) {
                player.nextDir = { x: 0, y: 1 };
            }
            if ((key === 'ArrowLeft' || key === 'a' || key === 'A') && !goingRight) {
                player.nextDir = { x: -1, y: 0 };
            }
            if ((key === 'ArrowRight' || key === 'd' || key === 'D') && !goingLeft) {
                player.nextDir = { x: 1, y: 0 };
            }
        }

        function handleMobileInput(key) {
            // Reutilizar a lógica existente simulando um evento
            // Impedir default se for toque para n dar zoom
            if (event && event.type === 'touchstart') {
                event.preventDefault();
            }

            handleInput({ key: key, preventDefault: () => { } });
        }

        /**
         * LÓGICA DA I.A. (CPU)
         */
        function updateCPULogic() {
            if (cpu.isDead) return;

            const head = cpu.body[0];

            // Movimentos possíveis
            const moves = [
                { x: 0, y: -1 }, // U
                { x: 0, y: 1 },  // D
                { x: -1, y: 0 }, // L
                { x: 1, y: 0 }   // R
            ];

            // Atualizar percepção do oponente com "lag"
            if (frameCounter % 3 === 0) {
                cpu.perceivedPlayerBody = player.body.map(p => ({ ...p }));
            }
            if (cpu.perceivedPlayerBody.length === 0 && player.body.length > 0) {
                cpu.perceivedPlayerBody = player.body.map(p => ({ ...p }));
            }

            // 1. Filtrar movimentos suicidas
            let safeMoves = moves.filter(move => {
                const nextX = head.x + move.x;
                const nextY = head.y + move.y;
                // Não pode voltar
                if (move.x === -cpu.dir.x && move.y === -cpu.dir.y) return false;
                return isSafeForCPU(nextX, nextY);
            });

            if (safeMoves.length === 0) return;

            // 2. Escolher o movimento que minimiza a distância até a fruta
            safeMoves.sort((a, b) => {
                const distA = getDistance(head.x + a.x, head.y + a.y, fruit.x, fruit.y);
                const distB = getDistance(head.x + b.x, head.y + b.y, fruit.x, fruit.y);
                return distA - distB;
            });

            cpu.dir = safeMoves[0];
        }

        function isSafeForCPU(x, y) {
            // Paredes 
            if (x < 0 || x >= GRID_COUNT || y < 0 || y >= GRID_COUNT) return false;

            // Colisão com PLAYER (Percepção Atrasada)
            for (let part of cpu.perceivedPlayerBody) {
                if (x === part.x && y === part.y) return false;
            }

            // Colisão com PRÓPRIO CORPO 
            for (let i = 0; i < cpu.body.length - 1; i++) {
                if (x === cpu.body[i].x && y === cpu.body[i].y) return false;
            }

            return true;
        }

        // Função Genérica (não usada mais pela IA diretamente, mas útil se precisarmos da verdade)
        function isSafe(x, y) { return true; } // Placeholder ou deprecated para lógica da IA

        function getDistance(x1, y1, x2, y2) {
            // Distância Manhattan (funciona bem para grids) ou Euclidiana
            // Manhattan: |x1 - x2| + |y1 - y2|
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        /**
         * ENGINE PRINCIPAL
         */
        function update() {
            if (isGameOver) return;
            frameCounter++;

            // Verificar scores para vitória
            if (player.score >= 500) {
                gameOver("VOCÊ ATINGIU 500 PONTOS! VENCEU!");
                return;
            }
            if (cpu.score >= 500) {
                gameOver("CPU ATINGIU 500 PONTOS! PERDEU!");
                return;
            }

            // Atualizar direção do player baseada no buffer
            player.dir = player.nextDir;

            // Calcular IA
            updateCPULogic();

            // Lógica de Morte da CPU (Respawn Delay)
            if (cpu.isDead) {
                if (Date.now() - cpu.deathTime > 2000) { // 2 segundos
                    respawnCpu();
                }
                // Não move a CPU se estiver morta
            } else {
                moveSnake(cpu);
            }

            // Mover Jogador
            moveSnake(player);

            // Verificar colisões
            let cpuCollision = false;

            if (!cpu.isDead) {
                if (checkCollisions(cpu)) cpuCollision = true;
            }

            if (checkCollisions(player) || cpuCollision) {
                return;
            }

            // Verificar se comeram a fruta
            checkFruit(player);
            if (!cpu.isDead) checkFruit(cpu);

            draw();
        }

        function moveSnake(snake) {
            // Nova cabeça
            const head = {
                x: snake.body[0].x + snake.dir.x,
                y: snake.body[0].y + snake.dir.y
            };

            // Adiciona nova cabeça
            snake.body.unshift(head);

            // Remove a cauda (será recolocada se comer fruta, mas fazemos isso na checkFruit logicamente:
            // aqui removemos sempre, e na checkFruit a gente só não removeu a cauda no frame anterior? 
            // Abordagem comum: move remove tail. Se comer, cresce (add tail back or don't remove).
            // Vamos usar: sempre remove, se comer, adiciona de volta (ou simplesmente não remove lá).
            // Para simplificar renderização suave: removemos aqui.)
            snake.body.pop();
        }

        function checkCollisions(snake) {
            const head = snake.body[0];

            // 1. Paredes
            if (head.x < 0 || head.x >= GRID_COUNT || head.y < 0 || head.y >= GRID_COUNT) {
                if (snake === cpu) {
                    gameOver(`${snake.name} bateu na parede!`);
                    return true;
                }
                gameOver(`${snake.name} bateu na parede!`);
                return true;
            }

            // 2. Colisão com o outro player
            const otherSnake = (snake === player) ? cpu : player;
            for (let part of otherSnake.body) {
                // Verificar se a cabeça de 'snake' bate em 'part'
                if (head.x === part.x && head.y === part.y) {
                    // NOVA REGRA: Se CPU bater no Jogador
                    if (snake === cpu && otherSnake === player) {
                        triggerCpuDeath();
                        return false; // Jogo continua
                    }

                    // Se Jogador bater na CPU (ou CPU bater em CPU)
                    // Se a CPU estiver MORTA (piscando), considerar "ghost" (sem colisão)?
                    // O usuario pediu "aparecer de novo", então durante o piscar ela é um fantasma.
                    if (otherSnake === cpu && cpu.isDead) {
                        return false; // Ignora colisão com corpo morto
                    }

                    gameOver(`${snake.name} colidiu com o inimigo!`);
                    return true;
                }
            }

            // 3. Auto-colisão
            for (let i = 1; i < snake.body.length; i++) {
                if (head.x === snake.body[i].x && head.y === snake.body[i].y) {
                    if (snake === cpu) {
                        triggerCpuDeath();
                        return false;
                    }

                    gameOver(`${snake.name} se enrolou!`);
                    return true;
                }
            }

            return false;
        }

        function checkFruit(snake) {
            const head = snake.body[0];
            if (head.x === fruit.x && head.y === fruit.y) {
                // Crescer
                const tail = snake.body[snake.body.length - 1];
                snake.body.push({ ...tail });

                snake.score += 10;
                updateUI();
                spawnFruit();
            }
        }

        function triggerCpuDeath() {
            if (cpu.isDead) return;

            // Transferir pontos
            player.score += cpu.score;
            cpu.score = 0;
            updateUI();

            // Setar estado de morte
            cpu.isDead = true;
            cpu.deathTime = Date.now();
        }

        function respawnCpu() {
            cpu.isDead = false;
            // Tentar encontrar uma posição segura aleatória
            let valid = false;
            let newBody = [];
            let attempts = 0;

            while (!valid && attempts < 100) {
                attempts++;
                // Posição aleatória para a cabeça
                const hx = Math.floor(Math.random() * (GRID_COUNT - 10)) + 5;
                const hy = Math.floor(Math.random() * (GRID_COUNT - 10)) + 5;

                // Corpo inicial (3 segmentos)
                newBody = [
                    { x: hx, y: hy },
                    { x: hx + 1, y: hy }, // Cauda para direita (já que dir será esquerda)
                    { x: hx + 2, y: hy }
                ];

                // Verificar colisão com paredes ou player
                valid = true;
                for (let part of newBody) {
                    // Paredes (implícito pelo random range, mas ok)
                    // Player
                    for (let pPart of player.body) {
                        if (part.x === pPart.x && part.y === pPart.y) valid = false;
                    }
                    // Fruta
                    if (part.x === fruit.x && part.y === fruit.y) valid = false;
                }
            }

            // Fallback se n achar
            if (!valid) {
                newBody = [
                    { x: GRID_COUNT - 6, y: 10 },
                    { x: GRID_COUNT - 5, y: 10 },
                    { x: GRID_COUNT - 4, y: 10 }
                ];
            }

            cpu.body = newBody;
            cpu.perceivedPlayerBody = []; // Resetar percepção ao renascer
            cpu.dir = { x: -1, y: 0 };
            // Score já foi resetado antes
        }

        function spawnFruit() {
            let valid = false;
            while (!valid) {
                fruit.x = Math.floor(Math.random() * GRID_COUNT);
                fruit.y = Math.floor(Math.random() * GRID_COUNT);

                valid = true;
                // Não spawnar em cima de cobras
                [player, cpu].forEach(s => {
                    for (let part of s.body) {
                        if (part.x === fruit.x && part.y === fruit.y) valid = false;
                    }
                });
            }
        }

        function gameOver(reason) {
            isGameOver = true;
            stopTimer();

            // Determinar vencedor e perdedor
            let winner = "";
            let color = "#fff";
            let playerLost = false;

            if (reason.includes("Empate")) {
                winner = "EMPATE!";
            } else if (reason.includes(player.name) || reason.includes("CPU ATINGIU")) {
                winner = "CPU VENCEU!";
                color = COLOR_CPU;
                playerLost = true;
                player.isDead = true; // Ativar efeito visual
            } else {
                winner = "VOCÊ VENCEU!";
                color = COLOR_PLAYER;
            }

            const titleHtml = `<span style="color:${color}; font-size: 1.5rem; text-shadow: 2px 2px #000;">${winner}</span>`;
            const reasonHtml = `<br><br><span style="font-size:0.8rem; color:#ccc">${reason}</span>`;

            const msg = document.getElementById('game-msg');
            msg.innerHTML = titleHtml + reasonHtml;

            // Enviar Score para API (Tempo de jogo)
            const duration = performance.now() - gameStartTime;

            const rankMsg = document.getElementById('rank-msg');
            rankMsg.innerText = "Sincronizando...";

            if (duration > 1000) {
                submitScoreSafe(player.name, player.score, duration).then(success => {
                    rankMsg.innerText = success ? "PONTUAÇÃO SALVA!" : "FALHA NO ENVIO";
                });
            } else {
                rankMsg.innerText = "";
            }

            const overlay = document.getElementById('overlay');
            // Se o jogador perdeu, dar delay para mostrar onde morreu
            if (playerLost) {
                // Animação de morte 
                let deathFrames = 0;
                const deathInterval = setInterval(() => {
                    draw();
                    deathFrames++;
                    if (deathFrames > 20) {
                        clearInterval(deathInterval);
                        overlay.classList.remove('hidden');
                    }
                }, 100);
            } else {
                overlay.classList.remove('hidden');
            }
        }

        function updateTimer() {
            if (gameState !== 'PLAYING') return;
            const now = performance.now();
            // Garantir que não seja negativo
            const diff = Math.max(0, Math.floor((now - gameStartTime) / 1000));

            const m = Math.floor(diff / 60).toString().padStart(2, '0');
            const s = (diff % 60).toString().padStart(2, '0');

            document.getElementById('timeVal').innerText = `${m}:${s}`;
        }

        function updateUI() {
            document.getElementById('pScoreVal').innerText = player.score;
            document.getElementById('cpuScoreVal').innerText = cpu.score;
        }

        /**
         * RENDERIZAÇÃO
         */
        function draw() {
            // Limpar fundo
            ctx.fillStyle = COLOR_BG;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Desenhar Grid (opcional, leve)
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;

            // Desenhar Fruta
            drawRect(fruit.x, fruit.y, COLOR_FRUIT);

            // Desenhar Player
            drawSnake(player);

            // Desenhar CPU
            drawSnake(cpu);
        }

        function drawSnake(snake) {
            // Efeito de piscar se estiver morto
            if (snake.isDead) {
                // Piscar a cada 200ms
                if (Math.floor(Date.now() / 200) % 2 === 0) {
                    return; // Não desenha neste frame (fundo preto)
                }
            }

            ctx.fillStyle = snake.color;
            snake.body.forEach((part, index) => {
                // Cabeça um pouco mais clara ou diferente
                if (index === 0) {
                    ctx.fillStyle = '#fff'; // Olho/Brilho na cabeça
                    drawRect(part.x, part.y, snake.color); // Base

                    // Desenhar um "olho" simples
                    ctx.fillStyle = 'white';
                    const px = part.x * TILE_SIZE;
                    const py = part.y * TILE_SIZE;
                    // Centro
                    ctx.fillRect(px + 4, py + 4, 12, 12);
                    // Volta a cor base
                    ctx.fillStyle = snake.color;
                    // Pupila baseada na cor da cobra
                    ctx.fillRect(px + 8, py + 8, 4, 4);
                } else {
                    ctx.fillStyle = snake.color;
                    drawRect(part.x, part.y, snake.color);
                }
            });
        }

        function drawRect(x, y, color) {
            ctx.fillStyle = color;
            // -1 no tamanho para dar efeito de grid separado
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 2, TILE_SIZE - 2);
        }

    </script>
</body>

</html>